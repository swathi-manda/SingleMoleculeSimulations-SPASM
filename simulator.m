% This code generates simulated single molecule data, using a Markov Chain Model. The data
% generated by this program can be analyzed using our ensemble averaging program, SPASM. A
% tutorial can be found in the user guide. Both the program and the user guide can be found at:
% https://github.com/GreenbergLab/SPASM.
%
% This code calculates the covariance of the simulated data, and the Signal Processing
% Toolbox is used to filter the covariance. If this toolbox is not installed, this step
% will be skipped.
%
% This code should be compatible with MATLAB versions R2016a through at least R2019a.

%% General parameters
numEvents = 100; % The number of myosin binding events to simulate.
fs = 2000; % The sampling frequency in Hz.
plotTF = true; % Whether to plot the results. Enter true or false.
saveTF = true; % Whether to save the results to a text file. Enter true or false.
% If you save the results to a text file, the data can be analyzed using the analysis
% program. See Appendix C of the user guide for more details.

%% States, rates, noise
% Matrix of transition rates between mechanical states. This assumes that the myosin transitions
% between states a (detached), b (first substep), and c (second substep). The values in the
% transition matrix give the rates of transitioning between states. For any given rate, the
% column gives the starting state and the row gives the ending state. For example, the value in
% column 3, row 1 gives the rate of transitioning from the third state (c, second substep) to the
% first state (a, detached).
trans = [
    % a    b    c
      0    0    4  ; % a - detached state
      0.5  0    0  ; % b - first substep
      0    70   0  ];% c - second substep

step_sizes = [0, 4.7, 6.6]; % Displacement of each state [a,b,c] relative to the first state.
step_size_var = [0, 0, 0]; % Variability in the displacements of each state [a,b,c].
high_freq_noise_state = [25, 15, 15]; % Amplitude of high frequency noise during each state [a,b,c].
low_freq_noise_A = 0.5; % Amplitude of low frequency noise.
low_freq_noise_f = 0.01; % Frequency of low frequency noise.

%% Coupling
% The position of bead A at time t is partially determined by two random numbers, Ar and Cr.
% The position of bead B at time t is partially determined by two random numbers, Br and Cr.
% The contribution of each random number simulates the coupling between the beads.
% For example, if A is determined completely by Ar and B is determined completely by Br, then the
% two beads will have uncorrelated motion.
% On the other hand, if A and B are both determined completely by Cr, then the two beads will
% have equivalent motion.

% These four functions determine the coupling between the beads. AArBound, for example,
% determines how much of bead A's position during a bound state is determined by Ar, such that
% 100*(1-AArBound)% of bead A's position during a bound state is determined by Cr.
% Each function should return a number between 0 and 1.

AArBound = @() 1;      % Proportion of A's position determined by Ar when bound.
BBrBound = @() 1;      % Proportion of B's position determined by Br when bound.
AArUnbound = @() rand; % Proportion of A's position determined by Ar when unbound.
BBrUnbound = @() rand; % Proportion of B's position determined by Br when unbound.

% rand returns a random number between 0 and 1.
% When AArBound = @() 1, then the beads will have uncorrelated motion.
% When AArUnbound = @() rand, then values of AArUnbound will vary uniformly between 0 and 1.
% You can change these functions however you would like, as long as they return a number
% between 0 and 1.
% Note that in the paper, these four variables are collectively referred to as f.

%% Covariance
% These are the filter window sizes used to calculate the covariance. Calculating and plotting
% the covariance allows you to judge whether the simulated data is suitable for event detection
% based on the covariance. These values do not affect how the simulated data is generated.
covwindow = 175; % Moving average filter window, for calculating the covariance.
covsmooth = 73; % 2nd order Savitzky-Golay filter, for smoothing the covariance.
% In the paper, these are referred to as w_c and w_s, respectively.

%% The below code generates the simulated data. The user does not need to change any of the below parameters.
numStates = size(trans,2); % The number of states.
states_trans = zeros(numStates*numEvents+1, 1); % The state before each transition.
time_trans = zeros(numStates*numEvents+1, 1); % The time at which each transition occurs.

% Convert matrix of rates to the Q matrix of the Markov Chain model.
Q = trans';
Q(1:numStates+1:end) = -sum(trans);

states_trans(1) = 1; % Set the state before the first transition (detached).
time_trans(1) = -log(rand)/(-Q(1,1)); % Determine the time of the first transition.

% This section generates a list of states and corresponding jump times.
for k = 1:numStates*numEvents
    i = states_trans(k); % The state before transition k.
    p = Q(i,:);
    p(i) = 0;
    p = p/sum(p); % The probabilities of attaining each state when starting from state i.

    j = find(rand < cumsum(p), 1); % The state after transition k.
    states_trans(k+1) = j;
    s = -log(rand)/(-Q(j,j)); % The time between transition k and transition k+1.
    time_trans(k+1) = time_trans(k)+s; % The time of transition k+1.
end

% This section converts the list of states to a list of displacements.
steps_trans = zeros(size(states_trans));
for s = 1:numStates
    steps_trans(states_trans==s) = step_sizes(s) - 0.5*step_size_var(s)*randn(1, sum(states_trans==s));
end

% This section interpolates values given the finite sampling rate.
time = (0:1/fs:time_trans(end))'; % Time, determined by the sampling rate.
states = interp1([0; time_trans], [states_trans; 0], time, 'previous'); % The state at each time point.
steps = interp1([0; time_trans], [steps_trans; 0], time, 'previous'); % The step at each time point.

% This section adds high frequency noise and generates coupling between the beads.
A = zeros(size(time));
B = zeros(size(time));
for s = 1:numStates
    n = sum(states==s); % The number of time points occupied by state s.
    aa = zeros(n, 1);
    bb = zeros(n, 1);
    if s > 1 % Myosin is bound.
        for i = 1:n
            aa(i) = AArBound();
            bb(i) = BBrBound();
        end
    else % Myosin is not bound.
        for i = 1:n
            aa(i) = AArUnbound();
            bb(i) = BBrUnbound();
        end
    end
    Ar = randn(n, 1); % Randomness in the high frequency noise of bead A.
    Br = randn(n, 1); % Randomness in the high frequency noise of bead B.
    Cr = randn(n, 1); % Randomness in the high frequency noise shared between beads A and B.
    A(states==s) = steps(states==s) - 0.5*high_freq_noise_state(s)*(aa.*Ar + (1-aa).*Cr);
    B(states==s) = steps(states==s) - 0.5*high_freq_noise_state(s)*((1-bb).*Cr + bb.*Br);
end

% This section adds low frequency noise and packages the output.
sim.A = A - 0.5*low_freq_noise_A*sin(2*pi*low_freq_noise_f*time);
sim.B = B - 0.5*low_freq_noise_A*sin(2*pi*low_freq_noise_f*time);
sim.time = time;
sim.fs = fs;
sim.key = steps;

% This section calculates the covariance.
A_filt = movmean(A, covwindow); % Filter with moving average.
B_filt = movmean(B, covwindow);
AB_filt = movmean(A.*B, covwindow);
sim.cov = AB_filt - A_filt.*B_filt; % Calculate the covariance.
try
    % Smoothing with a 2nd order Savitzky-Golay filter requires the Signal Processing Toolbox.
    sim.cov = sgolayfilt(sim.cov, 2, covsmooth);
catch
end

% This section generates plots.
if plotTF
    fig.beads_and_cov = figure('Visible', 'off');
    a1 = axes(fig.beads_and_cov, 'NextPlot', 'add');
    plot(a1, sim.time, sim.A);
    plot(a1, sim.time, sim.B);
    stairs(a1, [0; time_trans], [steps_trans; 0], 'r');
    ylabel(a1, 'position (nm)');
    axis(a1, 'tight');
    box(a1, 'on');
    a1.XTickLabel = [];
    
    hgt = a1.Position(4);
    a1.Position([2 4]) = [a1.Position(2) + 0.3*hgt, 0.7*hgt];
    a2 = axes(fig.beads_and_cov);
    a2.Position(4) = 0.28*hgt;
    plot(a2, sim.time, sim.cov);
    xlabel(a2, 'time (s)');
    ylabel(a2, 'covariance');
    axis(a2, 'tight');
    a1.XTick = a2.XTick;
    linkaxes([a1, a2], 'x');
    
    fig.hist = figure('Visible', 'off');
    a3 = axes(fig.hist);
    histogram(a3, sim.cov);
    xlabel(a3, 'covariance');
    ylabel(a3, 'bin count');
    
    fn = fieldnames(fig);
    for i = 1:numel(fn)
        fig.(fn{i}).Visible = 'on';
    end
end

% This section saves the data to a text file with a format that is compatible with the program.
if saveTF
    header{1} = {'Sample Rate', 'K1', 'K3', 'CAL1', 'CAL3'};
    header{2} = split(num2str([fs 1 1 1 1])); % Default K and CAL values are all 1.
    data = table;
    data.Trap1X = sim.A;
    data.Trap2X = sim.B;
    data.Key = sim.key;
    colNames = data.Properties.VariableNames;
    [name, path] = uiputfile('*.txt');
    if name == 0
        return
    end
    [path, name] = fileparts([path name]);
    name = [name '.txt'];
    
    fileID = fopen(fullfile(path, name), 'w');
    if fileID ~= -1
        prepHeader = [header{1}(:)'; header{2}(:)'];
        fprintf(fileID, '%s\t%s\n', prepHeader{:});
        printCols = @(C) fprintf(fileID, '%s\t', C);
        cellfun(printCols, colNames(1:end-1));
        fprintf(fileID, '%s', colNames{end});
        fprintf(fileID, '\n');
        format = '%f\t%f\t%f\n';
        fprintf(fileID, format, table2array(data)');
        fclose(fileID);
    end
end